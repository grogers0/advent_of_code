use std::io::{self, Read};
use std::ops::Add;

use lazy_static::lazy_static;

#[derive(Copy, Clone)]
enum Dir {
    Left, Right
}

#[derive(Copy, Clone)]
struct Pos {
    x: usize,
    y: usize,
}

impl Pos {
    fn new(x: usize, y: usize) -> Pos {
        Pos { x, y }
    }
}

#[derive(Copy, Clone)]
struct Offset {
    x: isize,
    y: isize,
}

impl Offset {
    fn new(x: isize, y: isize) -> Offset {
        Offset { x, y }
    }
}

impl Add<Offset> for Pos {
    type Output = Pos;
    fn add(self, offset: Offset) -> Pos {
        let x = (self.x as isize) + offset.x;
        let y = (self.y as isize) + offset.y;
        assert!(x >= 0 && y >= 0);
        Pos::new(x as usize, y as usize)
    }
}


struct Wind<'a> {
    dirs: &'a [Dir],
    idx: usize,
}

impl <'a> Wind<'a> {
    fn new(dirs: &'a [Dir]) -> Self {
        Self { dirs, idx: 0 }
    }

    fn next(&mut self) -> Dir {
        let ret = self.dirs[self.idx];
        self.idx += 1;
        self.idx %= self.dirs.len();
        ret
    }
}

struct Rock(Vec<Offset>);

lazy_static! {
    static ref ROCKS: Vec<Rock> = vec![
        // ####
        Rock(vec![Offset::new(0,0), Offset::new(1,0), Offset::new(2,0), Offset::new(3,0)]),
        // .#.
        // ###
        // .#.
        Rock(vec![Offset::new(1,0), Offset::new(0,1), Offset::new(1,1), Offset::new(2,1), Offset::new(1,2)]),
        // ..#
        // ..#
        // ###
        Rock(vec![Offset::new(0,0), Offset::new(1,0), Offset::new(2,0), Offset::new(2,1), Offset::new(2,2)]),
        // #
        // #
        // #
        // #
        Rock(vec![Offset::new(0,0), Offset::new(0,1), Offset::new(0,2), Offset::new(0,3)]),
        // ##
        // ##
        Rock(vec![Offset::new(0,0), Offset::new(1,0), Offset::new(0,1), Offset::new(1,1)]),
    ];
}

struct RockSpawner {
    idx: usize,
}

impl RockSpawner {
    fn new() -> Self {
        Self { idx: 0 }
    }
    fn next(&mut self) -> &'static Rock {
        let ret = &ROCKS[self.idx];
        self.idx += 1;
        self.idx %= ROCKS.len();
        ret
    }
}

struct Grid {
    rocks: Vec<bool>,
}

impl Grid {
    fn new() -> Grid {
        Grid { rocks: Vec::new() }
    }
}


fn parse(puzzle_input: &str) -> Vec<Dir> {
    puzzle_input.chars().map(|ch| {
        match ch {
            '<' => Dir::Left,
            '>' => Dir::Right,
            _ => panic!(),
        }
    }).collect()
}

fn part1(puzzle_input: &str) -> usize {
    let dirs = parse(puzzle_input);
    let mut wind = Wind::new(&dirs);
    0 // FIXME
}

fn part2(puzzle_input: &str) -> &str {
    "FIXME"
}

fn main() {
    let mut puzzle_input = String::new();
    io::stdin().read_to_string(&mut puzzle_input).unwrap();

    println!("{}", part1(&puzzle_input));
    println!("{}", part2(&puzzle_input));
}

#[cfg(test)]
mod tests {
    use super::*;

    const EX: &str = ">>><<><>><<<>><>>><<<>>><<<><<<>><>><<>>";

    #[test]
    fn test_part1() {
        assert_eq!(part1(EX), 3068);
    }

    #[test]
    fn test_part2() {
        // FIXME
    }
}
